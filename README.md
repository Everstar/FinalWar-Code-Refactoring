# AmazingGrave - FinalWar关卡 重构计划

> 软件架构与设计模式课程项目

## 简述

本小游戏是之前与三位同学组队完成的一个大游戏的四个关卡的最后一个关卡，该关卡由我独立完成。 <br>
过去对设计模式的不了解，写了很多冗余或者效率低下的代码。 <br>
在此重构以剔除这部分，并学习应用软件架构与设计模式课程中学习到的多种设计模式。 <br>

## 架构

- layer
	- 游戏层         GameLayer 
	- 血量显示层     LabelLayer  

- 精灵
	- 英雄
	- Boss
	- 小怪
	- 子弹


## 可重构优化之处

### 1.血量更新 - 观察者模式(Observer)

- 改进之前
	- 血量显示层的血量条为每一帧都获取英雄和Boss的血量并更新显示，但是对于计算机来说，在大多数时候并不需要更新。

- 计划改进之后
	- 可改进为观察者模式，每次血量发生变化之后，通知血量显示层更新UI

### 2.创建对象 - 工厂模式(Factory)

- 改进之前
	- 英雄、Boss、小怪、子弹以及各种动画和标签都分别创建，各种逻辑错综复杂。

- 改进之后
	- 使用工厂模式，可以将各种对象的创建放到同一个地方，增强代码的逻辑性和可读性。

### 3.创建不同的小怪 - 原型模式(Prototype)

- 改进之前
	- 创建小怪每次都要手工实例化

- 改进之后
	- 小怪种类个数固定，建立相应数目的原型并克隆，比每次用合适的状态手工实例化该类更方便一些。

### 4.迭代器(Iterator)

- 改进之前
	- 使用C++的Vector保存小怪数组、子弹数组

- 改进之后
	- 重写使用的vector的一部分，实现自己的iterator

### 5.状态模式(State)

- 改进之后
	- 根据Boss不同的血量，变换Boss不同的移动方向和子弹的移动方向和速度

### 变量或函数冗余

- 改进之前
	- 两层layer以及怪物管理器等都有指向英雄和Boss的指针，很多多余的指针可以被简化集中
	- 碰撞检测函数本应可以抽象到Entity类(人物对象的基类)，却在每一个子类重复实现

- 改进之后
	- 解耦合各个类之间的关系，删去重复冗余变量和抽象相似函数

### 代码规范

按照C++编码规范，修改代码的变量名称函数名称等，使代码可读性增强。



## 重构进度

### 工厂模式 **完成**

英雄 | Boss | 小怪 | 子弹 现在都是经过工厂Factory生产。

将生产对象的方式改进为工厂模式之后， 不再是零散的各处new出来，对之后的改动很方便，只要改一个地方的代码，全部新建的位置都可以用上。

### 原型模式 **完成**

针对五种小怪，建立五个原型。

（又踩上了之前A.h 和 B.h 相互包含引发的编译错误的问题。。浪费一小时解决。

将各种不同的小怪封装了起来，用户只要知道小怪的enum的名称即可使用。

### 状态模式 **完成**

Boss的三种状态
- boring
- excited
- insane

Boss的在不同状态下的行为模式逻辑被分解出来， 耦合度降低，不再是一大堆代码的逻辑判断if、else， 更方便地对某一个状态模式下的改动。

### 观察者模式 **完成**

观察者模式因为原先架构的原因 出现的Bug最多。
改的最累。

关闭了labellayer的update函数， 也就是说，减少了一个子线程。大大提高了效率。
之前要单独开一个子线程来更新血量，现在只在血量减少的时候更新。

### 迭代器 **完成**

队友写了一个ilist, 以链表实现的一个具有迭代器的向量。
以此来替代cocos的过于强大的cocos2d::Vector, 提升效率。

目前施工时间为 25 小时。
